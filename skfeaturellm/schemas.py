"""
Pydantic models for data validation and serialization.
"""

from typing import List, Literal, Optional

from pydantic import BaseModel, Field, model_validator


class FeatureDescription(BaseModel):
    """
    Schema for describing a single feature in the dataset.

    Attributes:
        name: The name of the feature
        type: The data type of the feature (e.g., 'int', 'float', 'str', 'datetime')
        description: A description of what the feature represents
    """

    name: str = Field(..., description="Name of the feature")
    type: str = Field(..., description="Data type of the feature")
    description: str = Field(
        ..., description="Description of what the feature represents"
    )

    def format(self) -> str:
        """
        Format the feature description in a human-readable way.

        Returns
        -------
        str
            Formatted feature description in the format: "name (type): description"
        """
        return f"- {self.name} ({self.type}): {self.description}"


class FeatureDescriptions(BaseModel):
    """
    Schema for a collection of feature descriptions.

    Attributes:
        features: List of feature descriptions
    """

    features: List[FeatureDescription] = Field(
        ..., description="List of feature descriptions"
    )

    def format(self) -> str:
        """
        Format all feature descriptions in a human-readable way.

        Returns
        -------
        str
            Formatted feature descriptions, one per line
        """
        return "\n".join(feature.format() for feature in self.features)


# =============================================================================
# Feature Engineering Ideas (LLM Output Schema)
# =============================================================================

# Supported transformation types - must match registered transformations
TransformationType = Literal[
    "add",
    "sub",
    "mul",
    "div",
    "log",
    "log1p",
    "sqrt",
    "abs",
    "exp",
    "square",
    "cube",
    "reciprocal",
]


class FeatureEngineeringIdea(BaseModel):
    """
    Schema for a feature engineering idea generated by the LLM.

    This schema is designed to map directly to the transformation executor,
    ensuring that LLM output can be reliably executed.

    Supports both binary operations (add, sub, mul, div) and unary operations
    (log, sqrt, abs, etc.).

    Attributes:
        type: The transformation type
        feature_name: Name for the resulting feature
        description: Explanation of what the feature represents and why it's useful
        column: Name of the column to transform (for unary operations)
        left_column: Name of the left operand column (for binary operations)
        right_column: Name of the right operand column (for binary column-column operations)
        right_constant: Constant value for the right operand (for binary column-constant operations)

    Examples:
        Unary operation (log):
        >>> FeatureEngineeringIdea(
        ...     type="log",
        ...     feature_name="log_income",
        ...     description="Log of income to reduce skewness",
        ...     column="income"
        ... )

        Binary operation (division of two columns):
        >>> FeatureEngineeringIdea(
        ...     type="div",
        ...     feature_name="income_per_person",
        ...     description="Average income per household member",
        ...     left_column="total_income",
        ...     right_column="household_size"
        ... )

        Binary operation (multiply column by constant):
        >>> FeatureEngineeringIdea(
        ...     type="mul",
        ...     feature_name="income_doubled",
        ...     description="Income multiplied by 2 for scaling",
        ...     left_column="income",
        ...     right_constant=2.0
        ... )
    """

    type: TransformationType = Field(
        ...,
        description="Transformation type",
    )
    feature_name: str = Field(
        ...,
        description="Name for the resulting feature",
        min_length=1,
    )
    description: str = Field(
        ...,
        description="Explanation of what the feature represents and why it's useful",
    )
    # For unary operations
    column: Optional[str] = Field(
        default=None,
        description="Name of the column to transform (for unary operations like log, sqrt, abs)",
    )
    # For binary operations
    left_column: Optional[str] = Field(
        default=None,
        description="Name of the left operand column (for binary operations)",
    )
    right_column: Optional[str] = Field(
        default=None,
        description="Name of the right operand column (for binary column-column operations)",
    )
    right_constant: Optional[float] = Field(
        default=None,
        description="Constant value for the right operand (for binary column-constant operations)",
    )

    @model_validator(mode="after")
    def validate_operands(self) -> "FeatureEngineeringIdea":
        """Validate operands based on transformation type."""
        # Unary operations
        unary_ops = {"log", "log1p", "sqrt", "abs", "exp", "square", "cube", "reciprocal"}
        # Binary operations
        binary_ops = {"add", "sub", "mul", "div"}

        if self.type in unary_ops:
            # Unary operations require only 'column'
            if self.column is None:
                raise ValueError(
                    f"Unary operation '{self.type}' requires 'column' field"
                )
            if self.left_column is not None or self.right_column is not None or self.right_constant is not None:
                raise ValueError(
                    f"Unary operation '{self.type}' should only have 'column' field, "
                    "not 'left_column', 'right_column', or 'right_constant'"
                )

        elif self.type in binary_ops:
            # Binary operations require left_column and either right_column or right_constant
            if self.left_column is None:
                raise ValueError(
                    f"Binary operation '{self.type}' requires 'left_column' field"
                )
            if self.column is not None:
                raise ValueError(
                    f"Binary operation '{self.type}' should not have 'column' field"
                )

            has_right_column = self.right_column is not None
            has_right_constant = self.right_constant is not None

            if has_right_column and has_right_constant:
                raise ValueError(
                    "Cannot provide both right_column and right_constant. "
                    "Use right_column for column-column operations, "
                    "or right_constant for column-constant operations."
                )

            if not has_right_column and not has_right_constant:
                raise ValueError(
                    "Must provide either right_column or right_constant. "
                    "Use right_column for column-column operations, "
                    "or right_constant for column-constant operations."
                )

        return self

    def to_executor_dict(self) -> dict:
        """
        Convert to a dictionary format compatible with TransformationExecutor.

        Returns
        -------
        dict
            Dictionary with fields appropriate for the transformation type
        """
        result = {
            "type": self.type,
            "feature_name": self.feature_name,
        }

        # Add fields based on what's present
        if self.column is not None:
            result["column"] = self.column
        if self.left_column is not None:
            result["left_column"] = self.left_column
        if self.right_column is not None:
            result["right_column"] = self.right_column
        if self.right_constant is not None:
            result["right_constant"] = self.right_constant

        return result


class FeatureEngineeringIdeas(BaseModel):
    """
    Schema for a list of feature engineering ideas generated by the LLM.

    This is the top-level schema used with LangChain's with_structured_output().
    """

    ideas: List[FeatureEngineeringIdea] = Field(
        ...,
        description="List of feature engineering ideas",
    )

    def to_executor_config(self) -> dict:
        """
        Convert to a configuration dict compatible with TransformationExecutor.from_dict().

        Returns
        -------
        dict
            Dictionary with 'transformations' key containing list of transformation configs
        """
        return {"transformations": [idea.to_executor_dict() for idea in self.ideas]}
