"""
Pydantic models for data validation and serialization.
"""

from typing import List, Literal, Optional

from pydantic import BaseModel, Field, model_validator


class FeatureDescription(BaseModel):
    """
    Schema for describing a single feature in the dataset.

    Attributes:
        name: The name of the feature
        type: The data type of the feature (e.g., 'int', 'float', 'str', 'datetime')
        description: A description of what the feature represents
    """

    name: str = Field(..., description="Name of the feature")
    type: str = Field(..., description="Data type of the feature")
    description: str = Field(
        ..., description="Description of what the feature represents"
    )

    def format(self) -> str:
        """
        Format the feature description in a human-readable way.

        Returns
        -------
        str
            Formatted feature description in the format: "name (type): description"
        """
        return f"- {self.name} ({self.type}): {self.description}"


class FeatureDescriptions(BaseModel):
    """
    Schema for a collection of feature descriptions.

    Attributes:
        features: List of feature descriptions
    """

    features: List[FeatureDescription] = Field(
        ..., description="List of feature descriptions"
    )

    def format(self) -> str:
        """
        Format all feature descriptions in a human-readable way.

        Returns
        -------
        str
            Formatted feature descriptions, one per line
        """
        return "\n".join(feature.format() for feature in self.features)


# =============================================================================
# Feature Engineering Ideas (LLM Output Schema)
# =============================================================================

# Supported transformation types - must match registered transformations
TransformationType = Literal["add", "sub", "mul", "div"]


class FeatureEngineeringIdea(BaseModel):
    """
    Schema for a feature engineering idea generated by the LLM.

    This schema is designed to map directly to the transformation executor,
    ensuring that LLM output can be reliably executed.

    Attributes:
        type: The transformation type (add, sub, mul, div)
        feature_name: Name for the resulting feature
        description: Explanation of what the feature represents and why it's useful
        left_column: Name of the left operand column
        right_column: Name of the right operand column (for column-column operations)
        right_constant: Constant value for the right operand (for column-constant operations)

    Examples:
        Division of two columns:
        >>> FeatureEngineeringIdea(
        ...     type="div",
        ...     feature_name="income_per_person",
        ...     description="Average income per household member",
        ...     left_column="total_income",
        ...     right_column="household_size"
        ... )

        Multiply column by constant:
        >>> FeatureEngineeringIdea(
        ...     type="mul",
        ...     feature_name="income_doubled",
        ...     description="Income multiplied by 2 for scaling",
        ...     left_column="income",
        ...     right_constant=2.0
        ... )
    """

    type: TransformationType = Field(
        ...,
        description="Transformation type: 'add', 'sub', 'mul', or 'div'",
    )
    feature_name: str = Field(
        ...,
        description="Name for the resulting feature",
        min_length=1,
    )
    description: str = Field(
        ...,
        description="Explanation of what the feature represents and why it's useful",
    )
    left_column: str = Field(
        ...,
        description="Name of the left operand column",
    )
    right_column: Optional[str] = Field(
        default=None,
        description="Name of the right operand column (for column-column operations)",
    )
    right_constant: Optional[float] = Field(
        default=None,
        description="Constant value for the right operand (for column-constant operations)",
    )

    @model_validator(mode="after")
    def validate_operands(self) -> "FeatureEngineeringIdea":
        """Validate that exactly one of right_column or right_constant is provided."""
        has_column = self.right_column is not None
        has_constant = self.right_constant is not None

        if has_column and has_constant:
            raise ValueError(
                "Cannot provide both right_column and right_constant. "
                "Use right_column for column-column operations, "
                "or right_constant for column-constant operations."
            )

        if not has_column and not has_constant:
            raise ValueError(
                "Must provide either right_column or right_constant. "
                "Use right_column for column-column operations, "
                "or right_constant for column-constant operations."
            )

        return self

    def to_executor_dict(self) -> dict:
        """
        Convert to a dictionary format compatible with TransformationExecutor.

        Returns
        -------
        dict
            Dictionary with 'type', 'feature_name', 'left_column', and
            either 'right_column' or 'right_constant'
        """
        result = {
            "type": self.type,
            "feature_name": self.feature_name,
            "left_column": self.left_column,
        }
        if self.right_column is not None:
            result["right_column"] = self.right_column
        if self.right_constant is not None:
            result["right_constant"] = self.right_constant
        return result


class FeatureEngineeringIdeas(BaseModel):
    """
    Schema for a list of feature engineering ideas generated by the LLM.

    This is the top-level schema used with LangChain's with_structured_output().
    """

    ideas: List[FeatureEngineeringIdea] = Field(
        ...,
        description="List of feature engineering ideas",
    )

    def to_executor_config(self) -> dict:
        """
        Convert to a configuration dict compatible with TransformationExecutor.from_dict().

        Returns
        -------
        dict
            Dictionary with 'transformations' key containing list of transformation configs
        """
        return {
            "transformations": [idea.to_executor_dict() for idea in self.ideas]
        }
